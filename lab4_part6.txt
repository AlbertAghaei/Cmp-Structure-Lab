/*********************************************************************
* Description:
* This project demonstrates how to program the PIC32 microcontroller so as to show the state of a switch (attached to the RB0 pin) on an LED (attached to the RB8 pin), in real time.
********************************************************************/
#include <xc.h>
#include "configbits.c"
.global main
.ent main
main:
// As we want the B port (meaning pins B0, B1, ..., B15) to be digital I/O, ANSELB = 0x0000:
la $8, ANSELB// Now $8 contains the memory address of ANSELB (which is 0xbf88_6100 as the datasheet asserts), so now we can edit the ANSELB.
la $7, ANSELA
sw $0, 0($8)// ANSELB = 0x0000
sw $0, 0($7)
/* The equivalent instruction for the instructions above is:
* lui $8, 0xbf88
* sw $0, 0x6100($8)
*/
/* Now we are going to assign B0, B1, ..., B7 as inputs to read from these pins and B8, B9, ..., B15 as outputs. (Note that in this particular project we do not need RA pins)
* So TRISB[0] = TRISB[1] = ... = TRISB[7] = 1 and TRISB[8] = TRISB[9] = ... = TRISB[15] = 0.
* Therefore TRISB = 0x00ff
*/
la $8, TRISB// Now $8 contains the memory address of TRISB (which is 0xbf88_6110 as the datasheet asserts), so now we can edit the TRISB.
ori $9, $0, 0x0000
sw $9, 0($8)// TRISB = 0x0000
la $7, TRISA// Now $8 contains the memory address of TRISB (which is 0xbf88_6110 as the datasheet asserts), so now we can edit the TRISB.
ori $12, $0, 0x00ff
sw $12, 0($7)// TRISA = 0x00ff
/* The equivalent instruction for the instructions above is:
* lui $8, 0xbf88
* ori $9, $0, 0x00ff
* sw $9, 0x6110($8)
*/
// Now RB0 to RB7 are set as inputs and RB8 to RB15 are set as outputs.
// We should have the address of PORTB to read from it and to detect any input; while we also need to have the address of LATB to write in it and show outputs:
la $10, PORTA// Now $10 contains the memory address of PORTA (which is 0xbf88_6120 as the datasheet asserts), so now we can read PORTB.
la $11, LATB// Now $11 contains the memory address of LATB (which is 0xbf88_6130 as the datasheet asserts), so now we can edit the LATB.
 
   ori $2, $0, 0x00c8 //200
   ori $3, $0, 0x0000 //counter
   ori $14, $0, 0x0000 //Previous sample
   ori $15 , $0, 0x0000 //Previous state
   ori $18 , $0, 0x0000 //Out
   
//lw $14,0($10)//to have sth to start comparing!!!!!
//andi $14, $14, 0x0001//mask $14
   //$7 current sample $14 prervious sample
loop:
lw $7, 0($10)// The input to our pins from an outer element (the swithces) is live detected and saved in the $8 register from PORTB.
andi $7, $7, 0x0001// The $8 is masked somehow we only detect RA0. Now the LSB of $8 shows whether the RA0 switch has been set.or $13,$7,$0
beq $7, $14, notreset
andi $3, $3, 0//counter1==0
or $14, $7, $0
j loop    
notreset:
addi $3, 1
or $14, $7, $0
slt $17,$3,$2
beq $17, $0, gotostate
j loop
gotostate:
    or $16,$7,$0
    and $3,$3,$0
    beq $15,$0,next
    or $15,$16,$0
    sll $19, $18, 8
    andi $19, $19, 0x0100
    sw $19, 0($11)
    j loop
next:
      bne $16,$0,toggle
      ori $15,$0,0x0000
      sll $19, $18, 8
      andi $19, $19, 0x0100
      sw $19, 0($11)
      j loop
//$15 previous state $16 current state
toggle:
    nor $18,$18,$18
    ori $15,$0,0x0001
    sll $19, $18, 8
    andi $19, $19, 0x0100
    sw $19, 0($11)
j loop//hasnt reached 200 so continue counting
.end main
